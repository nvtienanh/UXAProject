/*

Copyright (c) 2014, Patrick Niklaus, others
All rights reserved.

This file is licensed under the simplified 2-clause BSD license as provided
in by LICENSE file.

*/
#ifndef __TRAJECTORY_PLAYER_H__
#define __TRAJECTORY_PLAYER_H__

#include <MMM/Motion/Motion.h>

#include "../../bipedal.h"

namespace Bipedal
{

class TrajectoryException : std::exception
{
public:
    TrajectoryException(const std::string& trajectoryName)
    : errorMsg("Could not find a trajectory named " + trajectoryName)
    {
    }

    virtual const char* what()
    {
        return errorMsg.c_str();
    }
private:
    std::string errorMsg;
};

/**
 * Simple playback of trajectories generated by TrajectoryExporter
 */
class TrajectoryPlayer
{
public:
    TrajectoryPlayer(const std::string& motionPath, const std::string& goalMotionName)
        : frameCounter(0)
        , isRunning(false)
    {
        if (!loadMotion(motionPath, goalMotionName))
        {
            throw TrajectoryException(goalMotionName);
        }
    }

    /**
     * This steps the internal clock.
     * Should be called by callback in fixed intervals.
     *
     * Returns true as long as the is a control trajectory.
     */
    bool update(double timestep);

    /**
     * Start control sequence.
     */
    void start() { isRunning = true; }

    /**
     * Stop control sequence. The last played frame is kept as currentFrame.
     */
    void stop() { isRunning = false; }

    /**
     * Reset controller to initial state.
     */
    void reset();

public:
    bool isRunning;
    double time;
    int frameCounter;
    MMM::MotionPtr motion;
    MMM::MotionFramePtr nextFrame;
    MMM::MotionFramePtr currentFrame;

private:
    bool loadMotion(const std::string& motionPath, const std::string& goalMotionName);
};

typedef boost::shared_ptr<TrajectoryPlayer> TrajectoryPlayerPtr;

}

#endif
